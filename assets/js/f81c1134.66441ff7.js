"use strict";(self.webpackChunkneutrino=self.webpackChunkneutrino||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"first-blog-post","metadata":{"permalink":"/blog/first-blog-post","editUrl":"https://github.com/neutrino-gpu/neutrino/docs/blog/2024-12-24-5min/index.mdx","source":"@site/blog/2024-12-24-5min/index.mdx","title":"PyTorch One-Line Optimization","description":"Hello, welcome to Neutrino blogs!","date":"2024-12-24T00:00:00.000Z","tags":[{"inline":false,"label":"Introduction","permalink":"/blog/tags/hello","description":"Blogs introducing Neutrino basics"}],"readingTime":6.055,"hasTruncateMarker":false,"authors":[],"frontMatter":{"slug":"first-blog-post","title":"PyTorch One-Line Optimization","tags":["hello"]},"unlisted":false},"content":"import Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\nHello, welcome to Neutrino blogs!\\nThis blog series will continuously post our new findings on GPU programming and computing via `neutrino`,\\nour fine-grained and programmable GPU kernel observability platform like [eBPF](https://ebpf.io/) for Linux kernel!\\n\\n### Observing PyTorch Performance Issue with Neutrino!\\n\\nAs a GPU observability platform, `neutrino` provides an similar user interface as its CPU siblings [strace](https://man7.org/linux/man-pages/man1/strace.1.html)/[valgrind](https://valgrind.org/) for profiling nearly any computing workload on GPU, like Deep Learning with PyTorch. \\nTo demonstrate its power, how about let\'s started with an crazily easy one like the following line:\\n\\n```python title=\\"oneline.py\\"\\ntorch.zeros((4096, 4096), dtype=torch.float16, device=\\"cuda\\")\\n```\\n\\nFunctionality of the line is straightforward, create a 2D tensor of size `4096x4096` on GPU filled with zero in type of FP16. \\nAnd I believe most of us don\'t think this line has any potential performance issue, right \ud83e\uddd0? \\nBecause it\'s too straightforward and easy \ud83e\udee0.\\n\\nWell computer science is a practical subject so\\nlet\'s answer this question in the experiemental way with `neutrino` and more specifically, `neutrino`\'s block scheduling (`block_sched`) tool:\\n\\n```bash\\nneutrino -t block_sched python oneline.py # -t to specify tool\\n# output (truncated)\\n# \\n# \\n# \\n```\\n\\nHere `neutrino` suggests a kernel named `vectorized_elementwise...` (weird name comes from C++ template) is executed in `torch.zeros`.\\nThis behavior is expected as the kernel is used to fill allocated buffer with 0 for correct initialization.\\nBut the poor performance statistics is not expected, the kernel spend more than 25% time on block scheduling! What a waste of time and FLOPs!\\n\\n### What\'s block scheduling cost?\\n\\nNow it\'s time for some GPU programming internals. \\nMost compute platform like NVIDIA CUDA and AMD ROCm formulate GPU threads into blocks like 128 threads per block in this example.\\nAnd blocks will be scheduled onto GPUs to run parallely.\\nBut one common blind spot is that parallelism of block-level is not unlimited!\\n\\nIn fact, the parallelism of your kernel (`vectorized_elementwise` here) is bounded by GPU hardware, \\nlike on my A100 of 108 SM and 6 block/SM (see [CUDA Occupancy Calculator](https://docs.nvidia.com/cuda/cuda-c-programming-guide/#occupancy-calculator)), \\nonly 648 block can be executed parallely, far lower than required 65536. \\nIn such a case, blocks will be executed sequentially other than parallely, i.e., the 649-th block need to wait for an executing block finished to run.\\n\\nSimilar to context switch in CPU, GPU also spends additional time (hundreds of cycles) on finalizing an executing a block and scheduling next block. \\nAnd such scheduling time is called *block scheduling cost* here as the time is wasted from the perspective of computing:\\n\\n### How Neutrino measure this?\\n\\nAs many of us never heard of this term, block scheduling cost is mostly implicit. \\nAnd one possible reason is the difficulty to measure,\\nbecause GPU block scheduling is a hardware-behavior, i.e., \\nnot programmable,\\nand on the other hand, block execution is programmable but we are trying to measure the hole between blocks!\\n\\nNeutrino\'s `block_sched` tools solve this with a combination approach.\\nFirst, in trace collection we collect three runtime statistics for every block being scheduled, starting timestamp(clock), ending timestamp and the scheduled GPU SM id.\\nWith `neutrino`, this is as simple as following toml:\\n\\n```toml\\n\\n```\\n\\nThen, in post-trace analysis we can sort and analyze the scheduling per SM. Block scheduling cost can be estimated as the <u>start clock of next block - end clock of previous block</u>. You can check the code here.\\n\\n### How to optimize?\\n\\nThe best way to verify the correctness of Neutrino observation is to optimize in the way suggested and see if the performance is improved.\\n\\nHere suggestion given by `neutrino` is to reduce the block scheduling cost and one straightforward solution is to issue less blocks. \\nTo verify this, we can use Persistent Kernel (like [this example](https://triton-lang.org/main/getting-started/tutorials/09-persistent-matmul.html#sphx-glr-getting-started-tutorials-09-persistent-matmul-py)) that removes block scheduling cost via launching a persistent group of threads (at hardware capacity) and manage sequential part manually.\\n\\nA persistent `vectorized_elementwise` can be easily written in [Triton](https://triton-lang.org/main/index.html) via GPT:\\n\\n<Tabs>\\n\\n<TabItem value=\\"short\\" label=\\"Short\\">\\n\\n```python \\n@triton.jit\\ndef zero_init_kernel_persistent(output_ptr, numel, BLOCK_SIZE: tl.constexpr, NUM_SMS: tl.constexpr):\\n    start_pid = tl.program_id(axis=0)\\n    num_blocks = tl.cdiv(numel, BLOCK_SIZE)\\n    blocks_per_sm = num_blocks // NUM_SMS\\n    if start_pid < num_blocks % NUM_SMS:\\n        blocks_per_sm += 1\\n    block_id = start_pid - NUM_SMS\\n    for _ in range(blocks_per_sm):\\n        block_id += NUM_SMS\\n        offsets = block_id * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\\n        mask = offsets < numel\\n        tl.store(output_ptr + offsets, tl.zeros([BLOCK_SIZE], dtype=tl.float16), mask=mask)\\n```\\n</TabItem>\\n\\n<TabItem value=\\"long\\" label=\\"Full\\">\\n\\n```python\\nimport torch\\nimport triton\\nimport triton.language as tl\\n\\n@triton.jit\\ndef zero_init_kernel_persistent(output_ptr, numel, BLOCK_SIZE: tl.constexpr, NUM_SMS: tl.constexpr):\\n    # Get program ID\\n    start_pid = tl.program_id(axis=0)\\n    # Calculate number of blocks needed\\n    num_blocks = tl.cdiv(numel, BLOCK_SIZE)\\n    # Calculate blocks per SM\\n    blocks_per_sm = num_blocks // NUM_SMS\\n    if start_pid < num_blocks % NUM_SMS:\\n        blocks_per_sm += 1\\n    # Initialize block ID\\n    block_id = start_pid - NUM_SMS\\n    \\n    # Process multiple blocks per SM\\n    for _ in range(blocks_per_sm):\\n        block_id += NUM_SMS\\n        # Calculate offsets for this block\\n        offsets = block_id * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)\\n        # Create mask for valid elements\\n        mask = offsets < numel\\n        # Store zeros\\n        tl.store(output_ptr + offsets, tl.zeros([BLOCK_SIZE], dtype=tl.float16), mask=mask)\\n\\ndef zero_init_persistent(x: torch.Tensor):\\n    # Get total number of elements\\n    numel = x.numel()\\n    # Get number of SMs\\n    NUM_SMS = torch.cuda.get_device_properties(\\"cuda\\").multi_processor_count\\n    # Configure BLOCK_SIZE still at 128\\n    BLOCK_SIZE = 128\\n    # Launch kernel\\n    grid = lambda META: (min(NUM_SMS, triton.cdiv(numel, META[\'BLOCK_SIZE\'])),)\\n    zero_init_kernel_persistent[grid](x, numel, BLOCK_SIZE=BLOCK_SIZE, NUM_SMS=NUM_SMS, num_warps=8)\\n\\n# Test script\\nif __name__ == \\"__main__\\":\\n    # Test correctness\\n    shape = (4096, 4096)\\n    old = torch.zeros(shape, dtype=torch.float16, device=\'cuda\')\\n    new = torch.empty(shape, dtype=torch.float16, device=\'cuda\')\\n    zero_init_persistent(new)\\n    assert torch.allclose(old, new)\\n```\\n\\n</TabItem>\\n\\n</Tabs>\\n\\n\\nTo apply the change, we can call `torch.empty` to only allocate memory without initialization and call `zero_init_kernel_persistent` to initialize manually: \\n\\n```python\\n# REMOVE NEXT LINE\\n# 34,493ns (nsys, 1000 run\\n# REMOVE NEXT LINE\\nold = torch.zeros(shape, dtype=torch.float16, device=\'cuda\')\\n# ADD NEXT LINE\\n# nsys 1000 run: 25ms\\n# ADD NEXT LINE\\nnew = torch.empty(shape, dtype=torch.float16, device=\'cuda\')\\n# ADD NEXT LINE\\nzero_init_persistent(new)\\n```\\n\\nReplacing the line leads to around 33% acceleration, which supports Neutrino\'s observation of 25% scheduling cost.\\nAnother lazier solution is to use `cuMemset` driver call which totally eliminates the kernel launch (at least to developers outside Nvidia), which offers similar improvement:\\n\\n```python\\n# REMOVE NEXT LINE\\n# 34,493ns (nsys, 1000 run\\n# REMOVE NEXT LINE\\nold = torch.zeros(shape, dtype=torch.float16, device=\'cuda\')\\n# ADD NEXT LINE\\n# 24,630ns (nsys, 1000 run\\n# ADD NEXT LINE\\nnew = torch.empty(shape, dtype=torch.float16, device=\'cuda\')\\n# ADD NEXT LINE\\ndriver.cuMemsetD16(empty.data_ptr(), 0, 4096*4096)\\n```\\n\\n\ud83e\udd73Well Done\ud83e\udd73 \\nWith `neutrino`, we observe and accelerate a \\"mission impossible\\", a surprisingly easy `torch.zeros` performance issue that lies in our daily workflow!\\nMoreover, the underlying `vectorized_elementwise` not just lies in `torch.zeros` but also `torch.ones/arange/exp` (actually any elementwise unary operator\ud83e\udee3) and even plenty of implicit call to flush implicit buffers\ud83e\udee5!\\n\\n### Conclusion\\n\\nIn this 5-mins journey, we walk through the basic debug experience of Neutrino with a simple example as one-line of `torch.zeros`, demonstrating `neutrino`\'s amazing capability to discover performance issue from unexpected perspective.\\n\\nFinally I want to conclude with an inspiring question: \\n\\n> Even such a simple line can have such a big issue, how many potential performance issue in current GPU can we explore and optimize with Neutrino?\\n\\n### Further Reading\\nIf you are interested in `neutrino`, take a look at:\\n* [Introduction](/docs/intro): More detailed and insightful information of Neutrino\\n* Probe Design: How tools like `block_sched` is designed and implemented!\\n* Our later blog!"}]}}')}}]);