"use strict";(self.webpackChunkneutrino=self.webpackChunkneutrino||[]).push([[9759],{2668:(e,n,d)=>{d.r(n),d.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>x,frontMatter:()=>r,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"design/jit","title":"Tracing DSL and JIT","description":"Neutrino IR","source":"@site/docs/design/jit.md","sourceDirName":"design","slug":"/design/jit","permalink":"/docs/design/jit","draft":false,"unlisted":false,"editUrl":"https://github.com/neutrino-gpu/neutrino/docs/docs/design/jit.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Probe Engine","permalink":"/docs/design/probe-engine"},"next":{"title":"Utilities and Extension","permalink":"/docs/design/utils"}}');var s=d(4848),t=d(8453);const r={},c="Tracing DSL and JIT",l={},h=[{value:"Neutrino IR",id:"neutrino-ir",level:2},{value:"Special Operands",id:"special-operands",level:3},{value:"ALU Instructions",id:"alu-instructions",level:3},{value:"Memory Instructions",id:"memory-instructions",level:3},{value:"Other Instructions",id:"other-instructions",level:3},{value:"Branch Instructions",id:"branch-instructions",level:3}];function o(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"tracing-dsl-and-jit",children:"Tracing DSL and JIT"})}),"\n",(0,s.jsx)(n.h2,{id:"neutrino-ir",children:"Neutrino IR"}),"\n",(0,s.jsxs)(n.admonition,{type:"warning",children:[(0,s.jsxs)(n.p,{children:["\u26a0\ufe0f Currently only support operations in 64bit registers, ONLY ",(0,s.jsx)(n.code,{children:"ld/st"})," supports 32bit saving for more efficient memory operation."]}),(0,s.jsx)(n.p,{children:"\u26a0\ufe0f This is not finalized and is up to further modfication"})]}),"\n",(0,s.jsxs)(n.p,{children:["Neutrino IR's design is inspired by the ",(0,s.jsx)(n.a,{href:"https://www.ietf.org/archive/id/draft-thaler-bpf-isa-00.html",children:"eBPF ISA"}),", but we take a separation of output/input as most target GPU ISA has separated input/output."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, ",(0,s.jsx)(n.code,{children:"add"})," in eBPF ISA is ",(0,s.jsx)(n.code,{children:"add dst, src;;"})," aka ",(0,s.jsx)(n.code,{children:"dst += src"})," but in Neutrino IR it is ",(0,s.jsx)(n.code,{children:"add out, in1, in2"})," aka ",(0,s.jsx)(n.code,{children:"out = in1 + in2"})," (you can also use ",(0,s.jsx)(n.code,{children:"add dst, dst, src"})," for a similar semantic like eBPF ISA)."]}),"\n",(0,s.jsxs)(n.p,{children:["Currently, as we works on Python, we encode every instruction to be ",(0,s.jsx)(n.code,{children:"list[str]"})," where first item is instruction name and operands followed by, i.e., no binary format."]}),"\n",(0,s.jsx)(n.h3,{id:"special-operands",children:"Special Operands"}),"\n",(0,s.jsx)(n.p,{children:"Other than standard registers, we plan to have following operands for better value profiling"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Special Operand"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"NVIDIA PTX"}),(0,s.jsx)(n.th,{children:"AMD GCNAsm"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"dst"})}),(0,s.jsx)(n.td,{children:"will be replaced by destination"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{children:"\u2705"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"src"})}),(0,s.jsx)(n.td,{children:"will be replaced by source"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{children:"\u2705"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"out"})}),(0,s.jsx)(n.td,{children:"will be replaced by output (mostly 1st operand)"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{children:"\u2705"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"in1"})}),(0,s.jsx)(n.td,{children:"will be replaced by 1st input"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{children:"\u2705"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"in2"})}),(0,s.jsx)(n.td,{children:"will be replaced by 2nd input"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{children:"\u2705"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"in3"})}),(0,s.jsx)(n.td,{children:"will be replaced by 3rd input"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{children:"\u2705"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"bytes"})}),(0,s.jsx)(n.td,{children:"will be replaced by inst width"}),(0,s.jsx)(n.td,{children:"\u2705\xa0(only ld/st/cp)"}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"alu-instructions",children:"ALU Instructions"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Instruction"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"NVIDIA PTX"}),(0,s.jsx)(n.th,{children:"AMD GCNAsm"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"add, out, in1, in2"})}),(0,s.jsx)(n.td,{children:"out = in1 + in2"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{children:"\u2705"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"sub, out, in1, in2"})}),(0,s.jsx)(n.td,{children:"out = in1 - in2"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{children:"\u2705"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mul, out, in1, in2"})}),(0,s.jsx)(n.td,{children:"out = in1 * in2"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"div, out, in1, in2"})}),(0,s.jsx)(n.td,{children:"out = in1 / in2"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mod, out, in1, in2"})}),(0,s.jsx)(n.td,{children:"out = in1 % in2"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"lsh, out, in1, in2"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"out = in1 << in2"})}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"rsh, out, in1, in2"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"out = in1 >> in2"})}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"and, out, in1, in2"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"out = in1 and in2"})}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"or, out, in1, in2"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"out = in1 or in2"})}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"xor, out, in1, in2"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"out = in1 ^ in2"})}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"TODO: Support add32 kind of 32bit ALU instructions"}),"\n",(0,s.jsx)(n.h3,{id:"memory-instructions",children:"Memory Instructions"}),"\n",(0,s.jsx)(n.p,{children:"Due to stricter alignment requirements on GPU, we support limited memory instructions compared with standard eBPF semantics:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Instruction"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"NVIDIA PTX"}),(0,s.jsx)(n.th,{children:"AMD GCNAsm"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"stw, addr, reg"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.em,{children:"(u32"}),")addr=reg"]}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{children:"\u2705"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"stdw, addr, reg"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.em,{children:"(u64"}),")addr=reg"]}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{children:"\u2705"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ldw, addr, reg"})}),(0,s.jsxs)(n.td,{children:["reg=",(0,s.jsx)(n.em,{children:"(u64"}),")addr"]}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"lddw, addr, reg"})}),(0,s.jsxs)(n.td,{children:["reg=",(0,s.jsx)(n.em,{children:"(u64"}),")addr"]}),(0,s.jsx)(n.td,{}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Vectorized loading may be automatically (and implicitly) applied if backend find continuous saving opportunity."}),"\n",(0,s.jsx)(n.h3,{id:"other-instructions",children:"Other Instructions"}),"\n",(0,s.jsx)(n.p,{children:"We support many other kind of instructions for profiling usage:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Instruction"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"NVIDIA PTX"}),(0,s.jsx)(n.th,{children:"AMD GCNAsm"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"mov, out, in"})}),(0,s.jsx)(n.td,{children:"out = in"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{children:"\u2705"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"clock, out"})}),(0,s.jsx)(n.td,{children:"out = current clock"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"time, out"})}),(0,s.jsx)(n.td,{children:"out = current time"}),(0,s.jsx)(n.td,{children:"\u2705"}),(0,s.jsx)(n.td,{})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"cuid, out"})}),(0,s.jsx)(n.td,{children:"out = compute uint id"}),(0,s.jsx)(n.td,{children:"\u2705(smid)"}),(0,s.jsx)(n.td,{})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["We may also add supports for ",(0,s.jsx)(n.code,{children:"threadIdx"})," and ",(0,s.jsx)(n.code,{children:"blockIdx"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"branch-instructions",children:"Branch Instructions"}),"\n",(0,s.jsx)(n.p,{children:"Currently we don\u2019t support branch instructions (like the early stage of eBPF) as existing security verifier is not complete enough for safe branching."})]})}function x(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,d)=>{d.d(n,{R:()=>r,x:()=>c});var i=d(6540);const s={},t=i.createContext(s);function r(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);