"use strict";(self.webpackChunkneutrino=self.webpackChunkneutrino||[]).push([[6755],{8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>t});var o=r(6540);const l={},i=o.createContext(l);function s(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),o.createElement(i.Provider,{value:n},e.children)}},9495:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>t,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"probes/example","title":"Writing Probes","description":"Currently, Neutrino supports two methods of writing probes:","source":"@site/docs/probes/example.mdx","sourceDirName":"probes","slug":"/probes/example","permalink":"/docs/probes/example","draft":false,"unlisted":false,"editUrl":"https://github.com/neutrino-gpu/neutrino/docs/docs/probes/example.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Programmable Probes","permalink":"/docs/category/programmable-probes"},"next":{"title":"Probe Execution Model","permalink":"/docs/probes/model"}}');var l=r(4848),i=r(8453);const s={},t="Writing Probes",a={},d=[{value:"Pythonic Probe DSL",id:"pythonic-probe-dsl",level:2},{value:"Handcrafting Parallel Assembly",id:"handcrafting-parallel-assembly",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"writing-probes",children:"Writing Probes"})}),"\n",(0,l.jsx)(n.p,{children:"Currently, Neutrino supports two methods of writing probes:"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"High-level Pythonic Probe DSL offering better usability"}),"\n",(0,l.jsx)(n.li,{children:"Low-level Handcrafting Platform-specific Parallel Assembly offering more advanced control"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"We recommend new comers to get started with Pythonic Probe DSL and\nmodify the compiled assembly if existed cannot fulfill the need."}),"\n",(0,l.jsx)(n.h2,{id:"pythonic-probe-dsl",children:"Pythonic Probe DSL"}),"\n",(0,l.jsx)(n.p,{children:'Following is a "Hello World" example of Neutrino\'s probe DSL:'}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:'import neutrino\nimport neutrino.language as nl\n\nCALLBACK = "dmat.py"\n\n# declare shared registers across probes\nstart  : nl.u64 = 0 # starting clock\naligned: nl.u64 = 0\n\n# define probes with @neutrino.probe decorator\n@neutrino.probe(pos="kernel", level="thread")\ndef thread_start():\n    start = nl.clock()\n\n@neutrino.probe(pos="ld.global/st.global/cp.async.ca/cp.async.cg", size=16, count="dynamic") \ndef dmat():\n    aligned = nl.clock() - start\n    nl.save((aligned, nl.addr), dtype=nl.u32)\n'})}),"\n",(0,l.jsxs)(n.p,{children:["The basic usage is very similar to Triton that\nprobes are declared with ",(0,l.jsx)(n.code,{children:"@neutrino.probe"})," decorators (like ",(0,l.jsx)(n.code,{children:"@triton.jit"})," for Triton kernels)\nand you can use most familiar Python syntax like ",(0,l.jsx)(n.code,{children:"+-*/"}),".\nMoreover, Neutrino also extends many primitives like ",(0,l.jsx)(n.code,{children:"nl.clock()"})," for reading device-side clock and ",(0,l.jsx)(n.code,{children:"nl.addr"})," reading the address operands of ",(0,l.jsx)(n.code,{children:"ld.global"})," and ",(0,l.jsx)(n.code,{children:"st.global"})," instruction."]}),"\n",(0,l.jsx)(n.p,{children:"However, Neutrino also extends some features based on our uniqueness:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Users can declare shared registers in global spaces like ",(0,l.jsx)(n.code,{children:"start: nl.u64 = 0"})," declares a 64bit register named ",(0,l.jsx)(n.em,{children:"start"})," whose value will be initialized to 0 when program starts."]}),"\n",(0,l.jsxs)(n.li,{children:["Registers will be shared cross probes. For example, ",(0,l.jsx)(n.code,{children:"start"})," and its value can be used in both ",(0,l.jsx)(n.code,{children:"thread_start"})," and ",(0,l.jsx)(n.code,{children:"dmat"})," probes."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"@neutrino.probe"})," provides more in-depth control like ",(0,l.jsx)(n.code,{children:"pos"})," defining where the probe will be inserted, also ",(0,l.jsx)(n.code,{children:"size"}),", ",(0,l.jsx)(n.code,{children:"level"}),", and ",(0,l.jsx)(n.code,{children:"count"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["More configuration can be registered like ",(0,l.jsx)(n.code,{children:"CALLBACK='dmat.py'"})," specifies using ",(0,l.jsx)(n.code,{children:"dmat.py"})," to process the trace."]}),"\n"]}),"\n",(0,l.jsxs)(n.p,{children:["Please refer to ",(0,l.jsx)(n.a,{href:"/docs/design/jit",children:"Probe DSL"})," for more information."]}),"\n",(0,l.jsx)(n.p,{children:"This Probe DSL won't be executed by Python but will be just-in-time (JIT) compiled to Parallel Assembly like the following."}),"\n",(0,l.jsx)(n.h2,{id:"handcrafting-parallel-assembly",children:"Handcrafting Parallel Assembly"}),"\n",(0,l.jsxs)(n.p,{children:["The above Hello World example will be compiled to the following parallel assembly like ",(0,l.jsx)(n.a,{href:"https://docs.nvidia.com/cuda/parallel-thread-execution/",children:"PTX"})," for NVIDIA/CUDA in the TOML format:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-toml",children:'dynamic = true\ncallback = "dmat.py"\n\n[init]  \nposition = "kernel"\nbefore = """.reg .u64 %start;\n.reg .u64 %aligned;\nmov.u64  %start, %clock64;"""\n\n[load]\ndatamodel = "thread:16:dynamic"\nposition = "ld.global:st.global:cp.async.cg:cp.async.ca"\nbefore = """mov.u64  %aligned, %clock64;\nsub.u64 %aligned, %aligned, %start;\nSAVE.u64 {%aligned, ADDR};"""\n'})}),"\n",(0,l.jsxs)(n.p,{children:["TOML containing parallel assembly is the one really used by the probe engine.\nThe TOML contains global configurations like ",(0,l.jsx)(n.code,{children:"callback"})," inherited from DSL.\nAnd the Python code will be compiled into the assembly,\nlike ",(0,l.jsx)(n.code,{children:"start = nl.clock()"})," will be compiled to ",(0,l.jsx)(n.code,{children:"mov.u64  %start, %clock64;"}),", the PTX syntax of obtaining device-side clock.\nFinally, some helpers will be remained for the probe engine for final justification like ",(0,l.jsx)(n.code,{children:"ADDR"})," and ",(0,l.jsx)(n.code,{children:"SAVE"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["Please refer to ",(0,l.jsx)(n.a,{href:"/docs/design/probe-engine",children:"probe engine"})," for more information and specifications."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}}}]);