"use strict";(self.webpackChunkneutrino=self.webpackChunkneutrino||[]).push([[9828],{6731:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>s,contentTitle:()=>t,default:()=>_,frontMatter:()=>d,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"probes/trace","title":"Trace and Analysis","description":"This page is converted from the Jupyter Notebook, and we\'re optimizing the layout of this page.","source":"@site/docs/probes/trace.mdx","sourceDirName":"probes","slug":"/probes/trace","permalink":"/docs/probes/trace","draft":false,"unlisted":false,"editUrl":"https://github.com/neutrino-gpu/neutrino/docs/docs/probes/trace.mdx","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Probe Execution Model","permalink":"/docs/probes/model"},"next":{"title":"Reference and Internals","permalink":"/docs/category/reference-and-internals"}}');var i=r(4848),l=r(8453);const d={},t="Trace and Analysis",s={},o=[{value:"Structure Overview",id:"structure-overview",level:2},{value:"event.log from hook driver",id:"eventlog-from-hook-driver",level:2},{value:"kernel/ by probing engine",id:"kernel-by-probing-engine",level:2},{value:"callback for runtime analysis",id:"callback-for-runtime-analysis",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"trace-and-analysis",children:"Trace and Analysis"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"This page is converted from the Jupyter Notebook, and we're optimizing the layout of this page."})}),"\n",(0,i.jsx)(n.p,{children:'Now, after finishing the probing, we can explore the trace structure and perform analysis.\nAs a versatile system, Neutrino trace is not just a simple file and we formulate it into a organized "file system":'}),"\n",(0,i.jsx)(n.h2,{id:"structure-overview",children:"Structure Overview"}),"\n",(0,i.jsxs)(n.p,{children:["First, traces will be placed under ",(0,i.jsx)(n.code,{children:"NEUTRINO_TRACEDIR"})," (configurable via ",(0,i.jsx)(n.code,{children:"--trace"}),"), which is default to be ",(0,i.jsx)(n.code,{children:"./trace"}),". By ",(0,i.jsx)(n.code,{children:"ls"})," we can see traces arranged in order:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'os.listdir("./trace")\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"['Apr25_114624_1921397']\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Each directory corresponding to traces of a run and it's named by the time and pid.\nFor example ",(0,i.jsx)(n.code,{children:"Apr24_231539_1860576"})," means it's a run at:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"April 24, 23:15:39, of your local timezone"}),"\n",(0,i.jsx)(n.li,{children:"PID of this process is 1860576"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The use of ",(0,i.jsx)(n.code,{children:"pid"})," is due to the process-independent design of Neutrino that if your program uses multiple process, there'll be multiple trace dir distinguished by the ",(0,i.jsx)(n.code,{children:"pid"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Now we start to explore content of each trace. Probably the latest one."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# CITE https://stackoverflow.com/questions/9727673/list-directory-tree-structure-in-python\n# !sudo apt install tree # run this if your system don\'t have tree\ntracedir = os.listdir("./trace")[-1]\n!tree "./trace/{tracedir}" # an undocumented trick\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"    ./trace/Apr25_114624_1921397\n    \u251c\u2500\u2500 event.log\n    \u251c\u2500\u2500 kernel\n    \u2502\xa0\xa0 \u2514\u2500\u2500 0_bf524e8c48fdebc3962c3b36823d8d68b093ebb6\n    \u2502\xa0\xa0     \u251c\u2500\u2500 kernel.info\n    \u2502\xa0\xa0     \u251c\u2500\u2500 original.bin\n    \u2502\xa0\xa0     \u251c\u2500\u2500 original.ptx\n    \u2502\xa0\xa0     \u251c\u2500\u2500 probed.bin\n    \u2502\xa0\xa0     \u251c\u2500\u2500 probed.ptx\n    \u2502\xa0\xa0     \u251c\u2500\u2500 process.log\n    \u2502\xa0\xa0     \u251c\u2500\u2500 pruned.bin\n    \u2502\xa0\xa0     \u2514\u2500\u2500 pruned.ptx\n    \u251c\u2500\u2500 probe.toml\n    \u2514\u2500\u2500 result\n        \u2514\u2500\u2500 0.660526.bin\n    \n    3 directories, 11 files\n"})}),"\n",(0,i.jsx)(n.p,{children:"Here you can find:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"probe.toml"}),": a copy of probe code shown above, useful for repeating the experiment."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"event.log"}),": an important log of all the events captured by Hook Driver (Sec.4.1)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"kernel"}),": a folder containing all kernels captured and processed by Neutrino."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"result"}),": a folder containing all traces dumped"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"eventlog-from-hook-driver",children:"event.log from hook driver"}),"\n",(0,i.jsxs)(n.p,{children:["Now let's deep dive into the ",(0,i.jsx)(n.code,{children:"event.log"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'!cat "./trace/{tracedir}/event.log"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"    [pid] 1921397\n    [cmd] 26 python block_sched/raw.py \n    [info] dl 0x27c4350\n    [info] init success\n    [mem] cuMemAlloc_v2 0 dptr 7f3234000000 bytesize 33554432\n    [mod] cuLibraryLoadData 0 lib 0x8ba3040 code 0x7f33949cba28 type warpped_fatbin size 4962432\n    [mod] cuLibraryGetModule 0 mod 0x871e410 lib 0x8ba3040\n    [mod] cuModuleGetFunction func 0x90c68e0 mod 0x871e410 name _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1_\n    [exec] funcmap-not-find 0x90c68e0\n    [jit] find 0x90c68e0 name _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1_ bin 0x7f32407e4010 size 4962432\n    [jit] rename _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1_ 0_bf524e8c48fdebc3962c3b36823d8d68b093ebb6\n    [jit] mkdir ./trace/Apr25_114624_1921397/kernel/0_bf524e8c48fdebc3962c3b36823d8d68b093ebb6\n    [jit] write ./trace/Apr25_114624_1921397/kernel/0_bf524e8c48fdebc3962c3b36823d8d68b093ebb6/original.bin\n    [jit] subproc /home/root/anaconda3/envs/testenv/bin/python /home/root/anaconda3/envs/testenv/lib/python3.11/site-packages/neutrino/probe/cuda.py ./trace/Apr25_114624_1921397/kernel/0_bf524e8c48fdebc3962c3b36823d8d68b093ebb6 _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1_\n    [jit] python succeed\n    [jit] read ./trace/Apr25_114624_1921397/kernel/0_bf524e8c48fdebc3962c3b36823d8d68b093ebb6/kernel.info name _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1_ n_param 3 n_probe 1 trace_hook /home/root/anaconda3/envs/testenv/lib/python3.11/site-packages/neutrino/tools/block_sched.py\n    [jit] finish 0x90c68e0 name _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1_ n_param 3\n    [exec] funcmap-find 0x90c68e0 success\n    [exec] 1745552787265925120 param 1000000 10000000000 7f3234000000 \n    [exec] grid 32768 1 1 block 128 1 1 shared 0\n    [exec] grid 32768 warp  4 probe 16 total 2097152\n    [exec] probe-mem 2097152 (bytes)\n    [exec] succeed 0\n    [exec] save ./trace/Apr25_114624_1921397/result/0.660526.bin size 2097200\n    [exec] prologue 211.571716 kernel 0.059392 epilogue 2.958016 ratio 3613.098145\n    [analyze] subproc /home/root/anaconda3/envs/testenv/bin/python /home/root/anaconda3/envs/testenv/lib/python3.11/site-packages/neutrino/tools/block_sched.py ./trace/Apr25_114624_1921397/result/0.660526.bin\n    [analyze] succeed\n"})}),"\n",(0,i.jsx)(n.p,{children:"Let's break it down line to line. Note that pointers will change from run to run, just for illustration:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"[pid] 1860576"})," records the pid of this process"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"[cmd] 26 python block_sched/raw.py"})," records the command line, useful for classifying traces."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"[info] dl 0x26aa350"})," and ",(0,i.jsx)(n.code,{children:"[info] init success"})," records the status of Hook Driver initialization for internal checking."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"[mem]"})," records the ",(0,i.jsx)(n.a,{href:"https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__MEM.html#group__CUDA__MEM",children:"memory operations"}),", useful for checking illegal memory access. For example, here it states driver sucessfully (return code 0) allocate 33554432 bytes GMEM at ptr 0x7fdf78000000."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"[mod]"})," records the ",(0,i.jsx)(n.a,{href:"https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__MODULE.html#group__CUDA__MODULE",children:"module operations"}),", useful for checking GPU code. For example, here it states a function named ",(0,i.jsx)(n.code,{children:"_ZN2at6native29vectorized_elementwise_kernel..."})," was first loaded via ",(0,i.jsx)(n.code,{children:"cuLibraryLoadData"})," from a ",(0,i.jsx)(n.a,{href:"https://developer.nvidia.com/blog/cuda-pro-tip-understand-fat-binaries-jit-caching/",children:"fatbinary"})," and lowered via ",(0,i.jsx)(n.code,{children:"cuLibraryGetModule"})," and ",(0,i.jsx)(n.code,{children:"cuModuleGetFunction"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"[exec] funcmap-not-find"})," states internal function storage don't find the JIT record. This happens for every first-seen code and will trigger JIT probing."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"[jit]"})," records the interaction with probe engines. First it states kernel was ",(0,i.jsx)(n.code,{children:"find"})," from binary storage and was ",(0,i.jsx)(n.code,{children:"rename"})," to SHA1. Next, a folder is created under ",(0,i.jsx)(n.code,{children:"kernel"})," dir and the code was written to ",(0,i.jsx)(n.code,{children:"original.bin"}),". Then a subprocess is forked to launch the probe engine and we wait for the status."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"[exec]"})," records the execution of probing engine."]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"[analyze]"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"kernel-by-probing-engine",children:"kernel/ by probing engine"}),"\n",(0,i.jsxs)(n.p,{children:["Each directory under ",(0,i.jsx)(n.code,{children:"kernel/"})," corresponds to a kernel and is named by the SHA1 of kernel name with an indexed prefix for referencing."]}),"\n",(0,i.jsxs)(n.p,{children:["And under each kernel dir, there will be a ",(0,i.jsx)(n.code,{children:"original.bin"})," dumped by hook driver and all the rest are created by hooked driver.\nThe probe engine follows following steps:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"objdump original.bin"})," to extrace assembly into ",(0,i.jsx)(n.code,{children:"original.ptx"}),". Warning: ",(0,i.jsx)(n.code,{children:"original.ptx"})," can be LARGE because many kernels are fused into one file."]}),"\n",(0,i.jsxs)(n.li,{children:["Prune the asm by the kernel name (provided as ",(0,i.jsx)(n.code,{children:"sys.argv[-1]"}),", see above ",(0,i.jsx)(n.code,{children:"[exec] subproc"}),") and save to ",(0,i.jsx)(n.code,{children:"pruned.ptx"})," for checking."]}),"\n",(0,i.jsxs)(n.li,{children:["Probe the asm by the probe in ",(0,i.jsx)(n.code,{children:"NEUTRINO_PROBE"})," envariable and save it to ",(0,i.jsx)(n.code,{children:"probed.ptx"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"assemble"})," the ",(0,i.jsx)(n.code,{children:"pruned.ptx"})," and ",(0,i.jsx)(n.code,{children:"probed.ptx"})," into ",(0,i.jsx)(n.code,{children:".bin"})," of binary machine code."]}),"\n",(0,i.jsxs)(n.li,{children:["Write the ",(0,i.jsx)(n.code,{children:"kernel.info"})," for the hooked driver to read the enough metadata for ",(0,i.jsx)(n.code,{children:"[exec]"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Moreover, the probed engine will writes all the log into ",(0,i.jsx)(n.code,{children:"process.log"}),", let's take a look first."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'kernel_dir = os.listdir(f"./trace/{tracedir}/kernel")[0] # will be 0_xxx\n!cat "./trace/{tracedir}/kernel/{kernel_dir}/process.log"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"    ['']\n    [decompile] via cuobjdump -ptx\n    _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1_\n    ptxas -arch=sm_80 -m64 --verbose ./trace/Apr25_114624_1921397/kernel/0_bf524e8c48fdebc3962c3b36823d8d68b093ebb6/probed.ptx -o ./trace/Apr25_114624_1921397/kernel/0_bf524e8c48fdebc3962c3b36823d8d68b093ebb6/probed.bin\n    ptxas info    : 367 bytes gmem, 200 bytes cmem[4]\n    ptxas info    : Compiling entry function '_ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1_' for 'sm_80'\n    ptxas info    : Function properties for _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1_\n        0 bytes stack frame, 0 bytes spill stores, 0 bytes spill loads\n    ptxas info    : Used 18 registers, 376 bytes cmem[0]\n    \n    ptxas -arch=sm_80 -m64 --verbose ./trace/Apr25_114624_1921397/kernel/0_bf524e8c48fdebc3962c3b36823d8d68b093ebb6/pruned.ptx -o ./trace/Apr25_114624_1921397/kernel/0_bf524e8c48fdebc3962c3b36823d8d68b093ebb6/pruned.bin\n    ptxas info    : 367 bytes gmem, 200 bytes cmem[4]\n    ptxas info    : Compiling entry function '_ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1_' for 'sm_80'\n    ptxas info    : Function properties for _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1_\n        0 bytes stack frame, 0 bytes spill stores, 0 bytes spill loads\n    ptxas info    : Used 12 registers, 368 bytes cmem[0]\n    \n    # Neutrino Auto-Generated Code for Trace Reading\n    import struct\n    from typing import NamedTuple, List, Tuple\n    from neutrino import TraceHeader, TraceSection\n    \n    class block_sched(NamedTuple):\n    \tlstart: int\n    \telapse: int\n    \tsmid: int\n    \n    \n    def parse(path: str) -> Tuple[TraceHeader, List[TraceSection], List[List[block_sched]]]:\n        with open(path, \"rb\") as f:\n            gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, numProbes = struct.unpack(\"iiiiiiii\", f.read(32))\n            header: TraceHeader = TraceHeader(gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ, sharedMemBytes, numProbes)\n            assert header.numProbes == 1 # currently only one saving probe is supported\n            sections: List[TraceSection] = []\n            for _ in range(header.numProbes):\n                size, offset = struct.unpack(\"QQ\", f.read(16))\n                sections.append(TraceSection(size, offset))\n            gridSize = header.gridDimX * header.gridDimY * header.gridDimZ\n            blockSize = header.blockDimX * header.blockDimY * header.blockDimZ\n            records: List[List[block_sched]] = []\n            for i in range(gridSize):\n                records.append([])\n                for j in range(blockSize//32):\n                    lstart, elapse, smid = struct.unpack(\"QII\", f.read(16))\n                    records[i].append(block_sched(lstart, elapse, smid))\n            return header, sections, records\n"})}),"\n",(0,i.jsx)(n.p,{children:"Let's break it from top to down:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["First line is the kernel filtering information (set via ",(0,i.jsx)(n.code,{children:"--filter"}),"/",(0,i.jsx)(n.code,{children:"--kernel"}),"). It's empty here because we don't set anything."]}),"\n",(0,i.jsxs)(n.li,{children:["Second line is the ",(0,i.jsx)(n.code,{children:"objdump"})," information, stating the command used to dump the code."]}),"\n",(0,i.jsx)(n.li,{children:"Third line is the kernel name being used."}),"\n",(0,i.jsxs)(n.li,{children:["Then it's the command and logs of assembler (",(0,i.jsx)(n.code,{children:"ptxas"})," for NVIDIA). Please pay special attention to the last line stating no.registers used (for producing Table. 2) and constant memroy ",(0,i.jsx)(n.code,{children:"cmem[0]"})," (used for kernel parameters, here Neutrino use 8 bytes more for a 64bit pointer)."]}),"\n",(0,i.jsx)(n.li,{children:"Finally is the auto-generated Python code for trace reading conforming Sec. 4.4, helpful for building trace analysis tools, detailed presented in answering the 3rd question."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"And when the probing engine fails, it will also print out the trace back tree here for analysis, like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"['']\n[decompile] via cuobjdump -ptx\n_ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1_\nTraceback (most recent call last):\n  File \"/home/root/anaconda3/envs/testenv/lib/python3.11/site-packages/neutrino/probe/cuda.py\", line 747, in <module>\n    probed_ptx, probe_mem_sizes, trace_reading_code = probing(entry_section, probes)\n                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/root/anaconda3/envs/testenv/lib/python3.11/site-packages/neutrino/probe/cuda.py\", line 507, in probing\n    in3:  str = operands[3] if len(operands) >= 4 else None\n    ^^^\nUnboundLocalError: cannot access local variable 'out' where it is not associated with a value\n"})}),"\n",(0,i.jsx)(n.p,{children:"We build the probe engine in Python so you can easily debug and extend new functionalities if the current cannot fulfill your need."}),"\n",(0,i.jsxs)(n.p,{children:["Moreover, ",(0,i.jsx)(n.code,{children:"process.log"})," is for huamn-reading, another log for the hook driver to read back is the ",(0,i.jsx)(n.code,{children:"kernel.info"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'!cat "./trace/{tracedir}/kernel/{kernel_dir}/kernel.info"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"    _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1_\n    3\n    1\n    1,16\n    /home/root/anaconda3/envs/testenv/lib/python3.11/site-packages/neutrino/tools/block_sched.py\n    _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1__param_0,u32\n    _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1__param_1[2],align\n    _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1__param_2[8],align\n"})}),"\n",(0,i.jsxs)(n.p,{children:["From top to down, ",(0,i.jsx)(n.code,{children:"kernel.info"})," contains:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["First line is the kernel name, like ",(0,i.jsx)(n.code,{children:"_ZN2at6native29vectorized_elementwise_kernel..."})]}),"\n",(0,i.jsx)(n.li,{children:"Second line is the number of original kernel parameters, like 3."}),"\n",(0,i.jsxs)(n.li,{children:["Third line is the number of probes ",(0,i.jsx)(n.em,{children:"saving records"}),", here is 1. Then it's ",(0,i.jsx)(n.code,{children:"n=1"})," lines followed containing the datamodel, of type (",(0,i.jsx)(n.code,{children:"0:=thread/1:=warp"}),") and bytes, 16 here, saved for each thread/warp."]}),"\n",(0,i.jsxs)(n.li,{children:["Later, there'll be a line containing optional analyze hook, like ",(0,i.jsx)(n.code,{children:"block_sched.py"})," here."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["These will be parsed by the hook driver for execution usage (",(0,i.jsx)(n.code,{children:"[exec]"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["Finally, we can take a look at the difference of ",(0,i.jsx)(n.code,{children:"pruned.ptx"})," and ",(0,i.jsx)(n.code,{children:"probed.ptx"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'!cat "./trace/{tracedir}/kernel/{kernel_dir}/pruned.ptx"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"    .version 8.4\n    .target sm_80\n    .address_size 64\n    \n    //\n    .extern .func __assertfail\n    (\n    .param .b64 __assertfail_param_0,\n    .param .b64 __assertfail_param_1,\n    .param .b32 __assertfail_param_2,\n    .param .b64 __assertfail_param_3,\n    .param .b64 __assertfail_param_4\n    )\n    ;\n    .global .align 1 .b8 __unnamed_1[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_2[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_3[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_4[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_5[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_6[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_7[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_8[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_9[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_10[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_11[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_12[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_13[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_14[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_15[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_16[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_17[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_18[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_19[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_20[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 _ZN44_INTERNAL_14555b67_13_FillKernel_cu_e561d9726thrust20THRUST_200302_800_NS6system6detail10sequential3seqE[1];\n    .global .align 1 .b8 _ZN44_INTERNAL_14555b67_13_FillKernel_cu_e561d9724cuda3std3__48in_placeE[1];\n    .global .align 1 .b8 _ZN44_INTERNAL_14555b67_13_FillKernel_cu_e561d9724cuda3std6ranges3__45__cpo4swapE[1];\n    .global .align 1 .b8 $str$5[6] = {102, 97, 108, 115, 101};\n    .global .align 1 .b8 $str$6[58] = {47, 104, 111, 109, 101, 47, 104, 117, 97, 110, 103, 115, 48, 47, 119, 111, 114, 107, 100, 105, 114, 47, 100, 105, 115, 116, 47, 112, 121, 116, 111, 114, 99, 104, 47, 99, 49, 48, 47, 99, 111, 114, 101, 47, 68, 121, 110, 97, 109, 105, 99, 67, 97, 115, 116, 46, 104};\n    \n    \n    \n    .visible .entry _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1_(\n    .param .u32 _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1__param_0,\n    .param .align 2 .b8 _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1__param_1[2],\n    .param .align 8 .b8 _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1__param_2[8]\n    )\n    .maxntid 128, 1, 1\n    {\n    .reg .pred %p<6>;\n    .reg .b16 %rs<2>;\n    .reg .b32 %r<19>;\n    .reg .b64 %rd<15>;\n    \n    \n    ld.param.u16 %rs1, [_ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1__param_1];\n    ld.param.u64 %rd2, [_ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1__param_2];\n    ld.param.u32 %r4, [_ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1__param_0];\n    mov.u32 %r5, %ctaid.x;\n    shl.b32 %r1, %r5, 9;\n    sub.s32 %r2, %r4, %r1;\n    setp.lt.s32 %p1, %r2, 512;\n    cvta.to.global.u64 %rd1, %rd2;\n    @%p1 bra $L__BB66_2;\n    bra.uni $L__BB66_1;\n    \n    $L__BB66_2:\n    mov.u32 %r7, %tid.x;\n    setp.ge.s32 %p2, %r7, %r2;\n    add.s32 %r3, %r7, 384;\n    @%p2 bra $L__BB66_7;\n    \n    add.s32 %r9, %r7, 128;\n    setp.ge.s32 %p3, %r9, %r2;\n    add.s32 %r10, %r7, %r1;\n    mul.wide.u32 %rd7, %r10, 2;\n    add.s64 %rd8, %rd1, %rd7;\n    st.global.u16 [%rd8], %rs1;\n    @%p3 bra $L__BB66_7;\n    \n    add.s32 %r12, %r7, 256;\n    setp.ge.s32 %p4, %r12, %r2;\n    add.s32 %r14, %r10, 128;\n    mul.wide.u32 %rd9, %r14, 2;\n    add.s64 %rd10, %rd1, %rd9;\n    st.global.u16 [%rd10], %rs1;\n    @%p4 bra $L__BB66_7;\n    \n    add.s32 %r17, %r10, 256;\n    mul.wide.u32 %rd11, %r17, 2;\n    add.s64 %rd12, %rd1, %rd11;\n    st.global.u16 [%rd12], %rs1;\n    setp.ge.s32 %p5, %r3, %r2;\n    @%p5 bra $L__BB66_7;\n    \n    add.s32 %r18, %r3, %r1;\n    mul.wide.u32 %rd13, %r18, 2;\n    add.s64 %rd14, %rd1, %rd13;\n    st.global.u16 [%rd14], %rs1;\n    bra.uni $L__BB66_7;\n    \n    $L__BB66_1:\n    mul.wide.s32 %rd3, %r1, 2;\n    add.s64 %rd4, %rd1, %rd3;\n    mov.u32 %r6, %tid.x;\n    mul.wide.s32 %rd5, %r6, 8;\n    add.s64 %rd6, %rd4, %rd5;\n    st.global.v4.u16 [%rd6], {%rs1, %rs1, %rs1, %rs1};\n    \n    $L__BB66_7:\n    ret;\n    \n    }\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'!cat "./trace/{tracedir}/kernel/{kernel_dir}/probed.ptx"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"    .version 8.4\n    .target sm_80\n    .address_size 64\n    \n    //\n    .extern .func __assertfail\n    (\n    .param .b64 __assertfail_param_0,\n    .param .b64 __assertfail_param_1,\n    .param .b32 __assertfail_param_2,\n    .param .b64 __assertfail_param_3,\n    .param .b64 __assertfail_param_4\n    )\n    ;\n    .global .align 1 .b8 __unnamed_1[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_2[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_3[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_4[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_5[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_6[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_7[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_8[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_9[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_10[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_11[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_12[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_13[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_14[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_15[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_16[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_17[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_18[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_19[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 __unnamed_20[15] = {99, 97, 115, 116, 95, 97, 110, 100, 95, 115, 116, 111, 114, 101};\n    .global .align 1 .b8 _ZN44_INTERNAL_14555b67_13_FillKernel_cu_e561d9726thrust20THRUST_200302_800_NS6system6detail10sequential3seqE[1];\n    .global .align 1 .b8 _ZN44_INTERNAL_14555b67_13_FillKernel_cu_e561d9724cuda3std3__48in_placeE[1];\n    .global .align 1 .b8 _ZN44_INTERNAL_14555b67_13_FillKernel_cu_e561d9724cuda3std6ranges3__45__cpo4swapE[1];\n    .global .align 1 .b8 $str$5[6] = {102, 97, 108, 115, 101};\n    .global .align 1 .b8 $str$6[58] = {47, 104, 111, 109, 101, 47, 104, 117, 97, 110, 103, 115, 48, 47, 119, 111, 114, 107, 100, 105, 114, 47, 100, 105, 115, 116, 47, 112, 121, 116, 111, 114, 99, 104, 47, 99, 49, 48, 47, 99, 111, 114, 101, 47, 68, 121, 110, 97, 109, 105, 99, 67, 97, 115, 116, 46, 104};\n    \n    \n    \n    .visible .entry _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1_(\n    .param .u32 _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1__param_0,\n    .param .align 2 .b8 _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1__param_1[2],\n    .param .align 8 .b8 _ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1__param_2[8],\n    .param .u64 param_block_sched\n    )\n    .maxntid 128, 1, 1\n    {\n    .reg .b64 %lstart; // local start time (unit: cycle)\n    .reg .b64 %lend;    // local end time (unit: cycle)\n    .reg .b64 %elapsed; // thread elapsed time in u64\n    .reg .b32 %elapse;  // thread elapsed time in u32\n    mov.u64 %lstart, %clock64;\n    // begin buffer calculation\n    .reg .b32   %warpbuf<21>;                   // b32 reg to record access, will be optimized by ptxas\n    .reg .pred  %leader;                        // predicate register\n    .reg .pred  %joint_pred;                    // used to store AND result of %leader and instruction operand\n    mov.u32     %warpbuf2, %laneid;             // read lane id\n    setp.eq.u32 %leader, %warpbuf2, 0;          // check if thread is warp leader\n    @%leader mov.u32 %warpbuf3, %nwarpid;       // warpDim := number of warp in current group\n    @%leader mov.u32 %warpbuf4, %tid.x;         // threadIdx.x\n    @%leader mov.u32 %warpbuf5, %tid.y;         // threadIdx.y\n    @%leader mov.u32 %warpbuf6, %tid.z;         // threadIdx.z\n    @%leader mov.u32 %warpbuf7, %ntid.x;        // blockDim.x\n    @%leader mov.u32 %warpbuf8, %ntid.y;        // blockDim.y\n    @%leader mov.u32 %warpbuf18, %ntid.z;       // blockDim.z\n    @%leader mov.u32 %warpbuf9, %ctaid.x;       // blockIdx.x\n    @%leader mov.u32 %warpbuf10, %ctaid.y;      // blockIdx.y\n    @%leader mov.u32 %warpbuf11, %ctaid.z;      // blockIdx.z\n    @%leader mov.u32 %warpbuf12, %nctaid.x;     // gridDim.x\n    @%leader mov.u32 %warpbuf13, %nctaid.y;     // gridDim.y\n    @%leader mad.lo.s32 %warpbuf14, %warpbuf8,  %warpbuf6,  %warpbuf5;  // blockDim.y * threadIdx.z + threadIdx.y\n    @%leader mad.lo.s32 %warpbuf15, %warpbuf14, %warpbuf7,  %warpbuf4;  // thread_idx = (blockDim.y * threadIdx.z + threadIdx.y) * blockDim.x + threadIdx.x\n    @%leader div.s32 %warpbuf15, %warpbuf15, 32;                        // get persistent warpid instead of dynamic %warpid\n    @%leader mad.lo.s32 %warpbuf16, %warpbuf13, %warpbuf11, %warpbuf10; // gridDim.y * blockIdx.z + blockIdx.y\n    @%leader mad.lo.s32 %warpbuf17, %warpbuf16, %warpbuf12, %warpbuf9;  // block_idx = (gridDim.y * blockIdx.z + blockIdx.y) * gridDim.x + blockIdx.x\n    @%leader mul.lo.s32 %warpbuf19, %warpbuf7, %warpbuf8;\n    @%leader mul.lo.s32 %warpbuf20, %warpbuf19, %warpbuf18;\n    @%leader div.s32 %warpbuf20, %warpbuf20, 32;\n    @%leader mad.lo.s32 %warpbuf1,  %warpbuf17, %warpbuf20,  %warpbuf15; // buf_idx = block_idx * warpSize + warpIdx\n    // end buffer calculation\n    // begin block_sched buffer\n    .reg .b64 %buf_block_sched<5>;                          // register group defn\n    @%leader mul.wide.s32  %buf_block_sched4, %warpbuf1, 16; // get buffer location, no_bytes is per thread\n    @%leader ld.param.u64  %buf_block_sched3, [param_block_sched];        // load address from .param state space\n    @%leader cvta.to.global.u64 \t%buf_block_sched2, %buf_block_sched3;    // convert address to .global state space\n    @%leader add.s64 %buf_block_sched1, %buf_block_sched2, %buf_block_sched4;  // offset to get final thread-specific address\n    // end block_sched buffer\n    .reg .pred %p<6>;\n    .reg .b16 %rs<2>;\n    .reg .b32 %r<19>;\n    .reg .b64 %rd<15>;\n    \n    \n    ld.param.u16 %rs1, [_ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1__param_1];\n    ld.param.u64 %rd2, [_ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1__param_2];\n    ld.param.u32 %r4, [_ZN2at6native29vectorized_elementwise_kernelILi4ENS0_11FillFunctorIN3c104HalfEEENS_6detail5ArrayIPcLi1EEEEEviT0_T1__param_0];\n    mov.u32 %r5, %ctaid.x;\n    shl.b32 %r1, %r5, 9;\n    sub.s32 %r2, %r4, %r1;\n    setp.lt.s32 %p1, %r2, 512;\n    cvta.to.global.u64 %rd1, %rd2;\n    @%p1 bra $L__BB66_2;\n    bra.uni $L__BB66_1;\n    \n    $L__BB66_2:\n    mov.u32 %r7, %tid.x;\n    setp.ge.s32 %p2, %r7, %r2;\n    add.s32 %r3, %r7, 384;\n    @%p2 bra $L__BB66_7;\n    \n    add.s32 %r9, %r7, 128;\n    setp.ge.s32 %p3, %r9, %r2;\n    add.s32 %r10, %r7, %r1;\n    mul.wide.u32 %rd7, %r10, 2;\n    add.s64 %rd8, %rd1, %rd7;\n    st.global.u16 [%rd8], %rs1;\n    @%p3 bra $L__BB66_7;\n    \n    add.s32 %r12, %r7, 256;\n    setp.ge.s32 %p4, %r12, %r2;\n    add.s32 %r14, %r10, 128;\n    mul.wide.u32 %rd9, %r14, 2;\n    add.s64 %rd10, %rd1, %rd9;\n    st.global.u16 [%rd10], %rs1;\n    @%p4 bra $L__BB66_7;\n    \n    add.s32 %r17, %r10, 256;\n    mul.wide.u32 %rd11, %r17, 2;\n    add.s64 %rd12, %rd1, %rd11;\n    st.global.u16 [%rd12], %rs1;\n    setp.ge.s32 %p5, %r3, %r2;\n    @%p5 bra $L__BB66_7;\n    \n    add.s32 %r18, %r3, %r1;\n    mul.wide.u32 %rd13, %r18, 2;\n    add.s64 %rd14, %rd1, %rd13;\n    st.global.u16 [%rd14], %rs1;\n    bra.uni $L__BB66_7;\n    \n    $L__BB66_1:\n    mul.wide.s32 %rd3, %r1, 2;\n    add.s64 %rd4, %rd1, %rd3;\n    mov.u32 %r6, %tid.x;\n    mul.wide.s32 %rd5, %r6, 8;\n    add.s64 %rd6, %rd4, %rd5;\n    st.global.v4.u16 [%rd6], {%rs1, %rs1, %rs1, %rs1};\n    \n    $L__BB66_7:\n    @%leader mov.u64 %lend, %clock64;\n    @%leader sub.u64 %elapsed, %lend, %lstart; \n    @%leader cvt.u32.u64 %elapse, %elapsed; // convert to u32\n    @%leader st.global.u64 [%buf_block_sched1], %lstart;\n    @%leader add.s64 %buf_block_sched1, %buf_block_sched1, 8;\n    @%leader st.global.v2.u32 [%buf_block_sched1],  { %elapse,  %smid };\n    @%leader add.s64 %buf_block_sched1, %buf_block_sched1, 8;\n    ret;\n    \n    }\n"})}),"\n",(0,i.jsx)(n.p,{children:"Here we can the global definition are kept and the probe engine make following modification:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["A parameter ",(0,i.jsx)(n.code,{children:".param .u64 param_block_sched"})," is added"]}),"\n",(0,i.jsx)(n.li,{children:"Probes added at corresponding places, i.e., kernel start and end"}),"\n",(0,i.jsxs)(n.li,{children:["Buffer calculation in ",(0,i.jsx)(n.code,{children:"// begin buffer calculation"})," and ",(0,i.jsx)(n.code,{children:"// begin block_sched buffer"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"callback-for-runtime-analysis",children:"callback for runtime analysis"}),"\n",(0,i.jsxs)(n.p,{children:["Upon here, the last question is how the ",(0,i.jsx)(n.code,{children:"No.block:32768 Running:602241 Scheduling:87713(cycle)"})," is analyzed and printed."]}),"\n",(0,i.jsxs)(n.p,{children:["First, Neutrino will save all raw traces in the ",(0,i.jsx)(n.code,{children:"result"})," directory.\nRaw traces are of raw binary and is orderly named by the TIME since the driver starts."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'!ls "./trace/{tracedir}/result/"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"0.660526.bin\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To convert the raw binary into valuable analyzed results, Neutrino provides analyze_hook for user to register in the ",(0,i.jsx)(n.code,{children:"probe.toml"}),".\nFor example, here we register the ",(0,i.jsx)(n.code,{children:"block_sched.py"})," as the analyze hook. Relative paths will be resolved based on ",(0,i.jsx)(n.code,{children:"tools/"})," directory of installation folder."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'!cat "./trace/{tracedir}/probe.toml"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-toml",children:'    author = "Neutrino Team"\n    description = "Record start timestamp, elapsed time and smid of each warp\\ncan be reduced to NSight Occupancy and launch__waves_per_multiprocessor\\nThis is the same as block_sched but use local timer for better accuracy\\nwhile sacrifies the auto alignment from gloabl timer"\n    analyze_hook = "block_sched.py"\n    \n    [block_sched]\n    position = "kernel"\n    datamodel = "warp:16"\n    before = ".reg .b64 %lstart; // local start time (unit: cycle)\\n.reg .b64 %lend;    // local end time (unit: cycle)\\n.reg .b64 %elapsed; // thread elapsed time in u64\\n.reg .b32 %elapse;  // thread elapsed time in u32\\nmov.u64 %lstart, %clock64;"\n    after = "mov.u64 %lend, %clock64;\\nsub.u64 %elapsed, %lend, %lstart; \\ncvt.u32.u64 %elapse, %elapsed; // convert to u32\\nSAVE.u64 {%lstart}; // store start in u64 for alignment\\nSAVE.u32 {%elapse, %smid}; // store elapased time and core id"\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Real code of block_sched.py\n!cat {os.path.join(os.path.dirname(neutrino.__file__), "tools", "block_sched.py")}\n'})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'    # Neutrino Generated Code for Reading Trace\n    import struct\n    from typing import NamedTuple, List, Tuple\n    from neutrino import TraceHeader, TraceSection\n    \n    class block_sched(NamedTuple):\n        lstart: int\n        elapse: int\n        smid: int\n    \n    def parse(path: str):\n      with open(path, "rb") as f:\n        header: TraceHeader = TraceHeader(*struct.unpack("iiiiiiii", f.read(32)))\n        sections: List[TraceSection] = []\n        for _ in range(header.numProbes):\n            size, offset = struct.unpack("QQ", f.read(16))\n            sections.append(TraceSection(size, offset))\n        gridSize = header.gridDimX * header.gridDimY  * header.gridDimZ\n        blockSize = header.blockDimX * header.blockDimY * header.blockDimZ\n        records: List[List[block_sched]] = []\n        for i in range(gridSize):\n            records.append([])\n            for j in range(blockSize // 32):\n                lstart, elapse, smid = struct.unpack("QII", f.read(16))\n                records[i].append(block_sched(lstart, elapse, smid))\n      return header, sections, records\n    # END OF GENERATED CODE\n    import sys\n    import numpy as np\n    header, sections, records = parse(sys.argv[1]) # filled by path to trace\n    \n    unique_sms = set()    \n    for block in records:\n        unique_sms.add(block[0].smid)\n    \n    sm_timelines = []\n    for _ in range(len(unique_sms)):\n        sm_timelines.append([])\n    sched_times = [0.0] * len(unique_sms)\n    work_times = [0.0] * len(unique_sms)\n    \n    for cur in records:\n        # print(sm_timelines[cur[0].smid])\n        sched_out = False\n        smid = cur[0].smid\n        if len(sm_timelines[smid]) > 0:\n            for block in sm_timelines[smid]:\n                if block.lstart + block.elapse <= cur[0].lstart:\n                    # if cur[0].lstart - (block.lstart + block.elapse) < 100000:\n                    #     print(cur[0], block)\n                    sched_times[smid] += cur[0].lstart - (block.lstart + block.elapse)\n                    sm_timelines[smid].remove(block)\n                    sm_timelines[smid].append(cur[0])\n                    work_times[smid] += cur[0].elapse\n                    sched_out = True\n                    break\n                if not sched_out:\n                    sm_timelines[smid].append(cur[0]) \n                    work_times[smid] += cur[0].elapse\n                    break\n        else:\n            sm_timelines[smid].append(cur[0]) \n            work_times[smid] += cur[0].elapse\n    \n    print(f"No.block:{header.gridDimX * header.gridDimY  * header.gridDimZ} Running:{int(np.array(work_times).mean())} Scheduling:{int(np.array(sched_times).mean())}(cycle)")\n'})}),"\n",(0,i.jsxs)(n.p,{children:["There are two part of the code, separated by ",(0,i.jsx)(n.code,{children:"# END OF GENERATED CODE"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["1st part is the trace reading code auto-generated by Neutrino (see ",(0,i.jsx)(n.code,{children:"process.log"})," above) that are used to read ",(0,i.jsx)(n.code,{children:".bin"})," traces into Python objects familiar to developers."]}),"\n",(0,i.jsxs)(n.li,{children:["2nd part is the analyze code built upon the ",(0,i.jsx)(n.code,{children:"parse"})," written by developers. Here we simulate a FIFO scheduler based on traces collected, and print and calculate the scheduling times."]}),"\n"]})]})}function _(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>t});var a=r(6540);const i={},l=a.createContext(i);function d(e){const n=a.useContext(l);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),a.createElement(l.Provider,{value:n},e.children)}}}]);